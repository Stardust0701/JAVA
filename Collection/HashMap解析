详见http://blog.csdn.net/eson_15/article/category/6172207
1.
  hashMap实际上可以理解成一个数组，transient Entry<K,V>[] table，里面放的是entry实体，实体定义如下：
static class Entry<K,V> implements Map.Entry<K,V> {  
    final K key;  
    V value;  
    Entry<K,V> next; //指向下一个节点  
    int hash;
2.
  不论是put还是get，都根据key计算hash值，然后找到在数组中的位置，put的时候会把该位置的entry先“挂”起来，把新的放进去，
然后再把“挂”起来的entry“挂”到该entry后面，具体源码如下：
//创建一个Entry  
void createEntry(int hash, K key, V value, int bucketIndex) {  
    Entry<K,V> e = table[bucketIndex];//先把table中该位置原来的Entry保存  
    //在table中该位置新建一个Entry，将原来的Entry挂到该Entry的next  
    table[bucketIndex] = new Entry<>(hash, key, value, e);  
    //所以table中的每个位置永远只保存一个最新加进来的Entry，其他Entry是一个挂一个，这样挂上去的  
    size++;  
}  

3.
  刚开始初始化table不是在HashMap的构造函数里，因为构造函数中仅仅简单的将传进去的容量作为阈值。真正初始化table是在第一次往HashMap中put数据的时候
4.
  关于加载因子：
    若加载因子设置过大，则填满的元素越多，无疑空间利用率变高了，但是冲突的机会增加了，冲突的越多，链表就会变得越长，那么查找效率就会变得更低；
  若加载因子设置过小，则填满的元素越少，那么空间利用率变低了，表中数据将变得更加稀疏，但是冲突的机会减小了，这样链表就不会太长，查找效率变得更高。
  这看起来有点绕口，我举个简单的例子，如果数组容量为100，加载因子设置为80，即装满了80个才开始扩容，但是在装的过程中，可能有很多key对应相同的hash值，
  这样就会放到同一个链表中（因为没到80个不能扩容），这样就会导致很多链表都变得很长，也就是说，不同的key对应相同的hash值比数组填满到80个更加容易出现。
  但是如果设置加载因子为10，那么数组填满10个就开始扩容了，10个相对来说是很容易填满的，而且在10个内出现相同的hash值概率比上面的情况要小的多，
  一旦扩容之后，那么计算hash值又会跟原来不一样，就不会再冲突了，这样保证了链表不会很长，甚至就一个表头都有可能，但是空间利用率很低，
  因为始终有很多空间没利用就开始扩容。因此，就需要在“减小冲突”和“空间利用率”之间寻找一种平衡，这种平衡就是数据结构中有名的“时-空”矛盾的平衡。
  如果机器内存足够，并且想要提高查询速度的话可以将加载因子设置小一点；相反如果机器内存紧张，并且对查询速度没什么要求的话可以将加载因子设置大一点。
  一般我们都使用它的默认值，即0.75。
5.
  关于扩容：
    HashMap的默认容量是16,，扩容时，每次将容量变为原来的2倍
6.
  关于容量为何是2的幂次方，源码如下
  
  //这个方法有点意思，也是为什么容量要设置为2的幂的原因  
static int indexFor(int h, int length) {  
    // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";  
    return h & (length-1);  
}  

indexFor方法返回索引的位置，里面只做了一件事：h & (length-1)。这究竟做了什么？为什么这句能解释容量必须为2的幂呢？我们详细分析下：
首先，h & (length-1)相当于h & length，但是h % length效率比较低（HashTable中是这儿干的）。为啥h & (length-1)相当于h % length呢？
现在假设length为2的幂，那么length就可以表示成100......00的形式（表示至少1个0），那么length-1就是01111....11。对于任意小于length的数h来说
，与01111...11做&后都是h本身，对于h=length来说，&后结果为0，对于大于length的数h，&过后相当于h-j*length，也就是h % length。
这也就是为啥容量必须为2的幂了，为了优化，好做&运算，效率高。
其次，length为2的次幂的话，是偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h & (length-1)的最后一位可能为0也可能为1（取决于h的值），
即结果可能为奇数，也可能为偶数，这样便可以保证散列的均匀性，即均匀分布在数组table中；而如果length为奇数的话，很明显length-1为偶数，
它的最后一位是0，这样h & (length-1)的最后一位肯定为0，级只能为偶数，这样任何hash值都会被映射到数组的偶数下标位置上，这便浪费了近一半的空间！
因此，length取2的整数次幂，也是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀的散列。
